<!DOCTYPE html><HTML><HEAD><META charset="UTF-8" /><title>MMBot</title>
<meta name="viewport" content="width=device-width,initial-scale=1"><style type="text/css">
@import url("https://fonts.googleapis.com/css?family=Ruda&display=swap");  .draw_black { stroke:black; fill: transparent; }  body { background-color: #222; color: #CDCDCD;  font-family: Ruda; margin:0; font-size: 0.5cm;  }  svg { fill: #CDCDCD; font-size: 16px; }  svg .symbolname { font-size: 32px; font-weight: bold; }  svg .walletname { font-size: 15px; } svg .budgetextra { text-anchor: middle;  } svg .statslabelsbg linearGradient stop:nth-child(1){ stop-color: #0000; } svg .statslabelsbg linearGradient stop:nth-child(2){ stop-color: #444F; } svg ,statslabelsbig{  }  svg .budgetextra text:nth-child(3) { font-size: 22px; }  svg .labels { font-size: 10px; dominant-baseline: hanging; }  svg .statslabels { font-size: 12px; }  svg .stats { text-anchor: end; font-size: 25px; }  svg .assetslabels{ text-anchor: end; } svg .assets{  font-size: 21px; fill: #A8A; } svg .prices{ text-anchor: end; font-size: 21px; fill: #88f; font-style: italic; } svg .frame { stroke: #636363; fill: transparent; stroke-width: 2px;  } svg .frame stop:nth-child(1) { stop-color: #0008; } svg .frame stop:nth-child(2) {stop-color: #2228;}  svg .chart { stroke: #a1b1de; stroke-width: 3px; fill: transparent; }   svg .chartlabels{ font-size: 10px; dominant-baseline: text-after-edge; }  .colornumber.neg {fill: #ff8080;}  .colornumber.pos { fill: #78c378; }  .colornumber.zero { fill: #888; }  .colornumber.na { fill: #888;  }  svg .assets .flashing { animation: 1s blink infinite; }  svg .assets .buy { fill: #8F0 } svg .assets .sell { fill: #F80 }  @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.2; } 100% { opacity: 1; } }  #main_panel { display: flex; flex-wrap: wrap; flex-direction: row;  gap: 2vmin; justify-content: center; margin: 2vmin; }  #main_panel > * { width: 14cm; flex-shrink: 1; }

x-slider { display: inline-block; padding-left: 5.2em; position: relative; } x-slider > div { height: 100%; } x-slider > div >input { display: block; box-sizing: border-box; width:100%; height:100%; text-align: center; } x-slider > div:nth-child(2) { position:absolute; left: 0; top:0; width: 5em; bottom:0; }  x-slider[disabled]>*{ opacity: 0.3; pointer-events: none;  }   x-checkbox { display: inline; }  x-checkbox.checked { font-weight: bold; }  x-checkbox > span{ display: inline-block; height: 1.2em; width: 2.4em; border: 2px solid #AAA; border-radius: 0.5em; transition: all 0.2s; position:relative; vertical-align: middle; margin: 0.2em; }  x-checkbox > span >span { display:block; border-radius: 0.35em; background-color: #9a5050; position:absolute; left: 0; top: 0; bottom: 0; right: 50%;  transition: all 0.2s; }  x-checkbox.checked >span { border: 2px solid #dcdcdc; }  x-checkbox.checked >span>span { background-color: #4CAF50; right: 0; left: 50%; }

</style></HEAD><BODY><div id="main_panel">

</div><script type="text/javascript">
"use strict"; var mmbot={}; 
  var TemplateJS = function(){ "use strict";    function once(element, event, args) {  return new Promise(function(ok) {  function fire(z) { element.removeEventListener(event, fire, args);  ok(z); }  element.addEventListener(event, fire, args); }); };    function delay(time, arg) { return new Promise(function(ok) { setTimeout(function() { ok(arg); },time); }); };      function waitForRender(elem, arg, timeout){ if (!timeout) timeout = 10; if (elem.isConnected) return Promise.resolve(arg); init_waitForRender(); return new Promise(function(ok, err){  waitForRender_list.push({ elem:elem, fn:ok, err:err, arg:arg, time:Date.now(), timeouts: timeout, st:true }); });  };    function waitForRemove(elem, arg, timeout) { if (timeout === undefined) timeout = null; if (!elem.isConnected) return Promise.resolve(arg); init_waitForRender(); return new Promise(function(ok, err){  waitForRender_list.push({ elem:elem, fn:ok, err:err, arg:arg, time:Date.now(), timeouts: timeout, st:false }); });  }  function init_waitForRender() { if (waitForRender_observer == null) { waitForRender_observer = new MutationObserver(waitForRender_callback);  waitForRender_observer.observe(document,  {attributes: false, childList: true, characterData: false, subtree:true}); }  }  var waitForRender_list = []; var waitForRender_observer = null; var waitForRender_callback = function() { if (waitForRender_list.length == 0) { waitForRender_observer.disconnect(); waitForRender_observer = null; } else { var tm = Date.now(); waitForRender_list = waitForRender_list.reduce(function(acc,x){  if (x.elem.isConnected == x.st) { x.fn(x.arg); } else if (x.timeouts !== null) { if (tm - x.time > 1000) { x.time = tm; if (--x.timeouts <= 0) { x.err(new Error("waitForRender/waitForRemove timeout")); return acc; }  }  acc.push(x); } else { acc.push(x); } return acc; },[]); } };     function Animation(elem) { this.elem = elem;  var computed = window.getComputedStyle(elem, null);  if (computed.animationDuration != "0" && computed.animationDuration != "0s") { this.type = this.ANIMATION; this.dur = computed.animationDuration; } else if (computed.transitionDuration != "0" && computed.transitionDuration != "0s") { this.type = this.TRANSITION; this.dur = computed.transitionDuration; } else { this.type = this.NOANIM; this.dur = "0s"; }  if (this.dur.endsWith("ms")) this.durms = parseFloat(this.dur); else if (this.dur.endsWith("s")) this.durms = parseFloat(this.dur)*1000; else if (this.dur.endsWith("m")) this.durms = parseFloat(this.dur)*60000; else this.durms = 1000; }; Animation.prototype.ANIMATION = 1; Animation.prototype.TRANSITION = 2; Animation.prototype.NOANIM = 0;  Animation.prototype.isAnimated = function() { return this.type != this.NOANIM; }; Animation.prototype.isTransition = function() { return this.type == this.TRANSITION; }; Animation.prototype.isAnimation = function() { return this.type == this.ANIMATION; };  Animation.prototype.restart = function() { var parent = this.elem.parentElement; var next = this.elem.nextSibling; parent.insertBefore(this.elem, next);  };  Animation.prototype.wait = function(arg) { var res; switch (this.type) { case this.ANIMATION: res = Promise.race([delay(this.durms),once(this.elem,"animationend")]);break; case this.TRANSITION: res = Promise.race([delay(this.durms),once(this.elem,"transitionend")]);break; default: case this.NOTHING:res = Promise.resolve();break; } if (arg !== undefined) { return res.then(function(){return arg;}); } else { return res; } };    function removeElement(element, skip_anim) { if (!element.isConnected) return Promise.resolve(); if (element.dataset.closeAnim && !skip_anim) {  var remopen = element.dataset.openAnim; if (remopen && !element.classList.contains(remopen)) { return removeElement(element,true); }  var closeAnim = element.dataset.closeAnim; return waitForDOMUpdate().then(function() { if (remopen)  element.classList.remove(remopen); element.classList.add(closeAnim); var anim = new Animation(element); if (anim.isAnimation())  anim.restart();  return anim.wait(); }).then(function() { return removeElement(element,true);  }) } else { var event = new Event("remove"); element.parentElement.removeChild(element); element.dispatchEvent(event); return Promise.resolve(); }  };  function waitForDOMUpdate() { return new Promise(function(ok) { window.requestAnimationFrame(function() { window.requestAnimationFrame(ok); }); }) };  function addElement(parent, element, before) { if (before === undefined) before = null; if (element.dataset.closeAnim) { element.classList.remove(element.dataset.closeAnim); } element.classList.remove(element.dataset.openAnim); parent.insertBefore(element,before); window.getComputedStyle(element); if (element.dataset.openAnim) { waitForDOMUpdate().then(function() { element.classList.add(element.dataset.openAnim);  }); } };  function createElement(def) { if (typeof def == "string") { return document.createElement(def); } else if (typeof def == "object") { if ("tag" in def) { var elem = document.createElement(def.tag); var attrs = def.attrs || def.attributes; if (typeof attrs == "object") { for (var i in attrs) { elem.setAttribute(i,attrs[i]); } } if ("html" in def) { elem.innerHTML=def.html; } else if ("text" in def) { elem.appendChild(document.createTextNode(def.text)); } else { var content = def.content || def.value || def.inner; if (content !== undefined) { elem.appendChild(loadTemplate(content)); } } return elem; } else if ("text" in def) { return document.createTextNode(def.text); } } return document.createElement("div"); };  function loadTemplate(templateID) { var tempel; if (typeof templateID == "string") { tempel = document.getElementById(templateID); if (!tempel) { throw new Error("Template element doesn't exists: "+templateID);  } } else if (typeof templateID == "object") { if (templateID instanceof Element) { tempel = templateID; } else if (Array.isArray(templateID)) { return templateID.reduce(function(accum,item){ var x = loadTemplate(item); if (accum === null) accum = x; else accum.appendChild(x); return accum; },document.createDocumentFragment()); } else { return createElement(templateID); } } var cloned; if ("content" in tempel) { cloned = document.importNode(tempel.content,true); } else { cloned = document.createDocumentFragment(); var x= tempel.firstChild; while (x) { cloned.appendChild(x.cloneNode(true)); x = x.nextSibling; } } return cloned;  };   function View(elem) { if (typeof elem == "string") elem = document.getElementById(elem); this.root = elem; this.marked =[]; this.groups =[]; this.rebuildMap();  if (this.root.dataset && this.root.dataset.openAnim) { this.root.classList.add(this.root.dataset.openAnim); }  };    View.prototype.getRoot = function() { return this.root; };    View.prototype.setContent = function(elem) { if (elem instanceof View)  return this.setContent(elem.getRoot());  this.clearContent(); this.defaultAction = null; this.cancelAction = null; this.root.appendChild(elem); this.rebuildMap(); };    View.prototype.loadTemplate = function(templateRef) { this.setContent(loadTemplate(templateRef)); };  View.prototype.replace = function(view, skip_wait) {  if (this.lock_replace) { view.lock_replace = this.lock_replace = this.lock_replace.then(function(v) { delete view.lock_replace; return v.replace(view,skip_wait); }); return this.lock_replace; }  var nx = this.getRoot().nextSibling; var parent = this.getRoot().parentElement; var newelm = view.getRoot();  view.modal_elem = this.modal_elem; delete this.modal_elem;  if (!skip_wait) { var mark = document.createComment("#"); parent.insertBefore(mark,nx);  view.lock_replace = this.close().then(function(){  addElement(parent,view.getRoot(), mark); parent.removeChild(mark); delete view.lock_replace; return view; }); return view.lock_replace; } else { this.close(); addElement(parent,view.getRoot(),nx); return Promise.resolve(view); }  };  View.HIDDEN = 0;  View.VISIBLE = 1;  View.TRANSPARENT=-1;  View.prototype.setVisibility = function(vis_state) { if (vis_state == View.VISIBLE) { this.root.hidden = false; this.root.style.visibility = ""; } else if (vis_state == View.TRANSPARENT) { this.root.hidden = false; this.root.style.visibility = "hidden";  } else { this.root.hidden = true; } };  View.prototype.show = function() { this.setVisibility(View.VISIBLE); };  View.prototype.hide = function() { this.setVisibility(View.HIDDEN); };    View.prototype.close = function(skip_anim) { return removeElement(this.root).then(function() {  if (this.modal_elem && this.modal_elem.isConnected)  this.modal_elem.parentElement.removeChild(this.modal_elem);  }.bind(this)); };    View.prototype.open = function(elem) { if (!elem) elem = document.body; addElement(elem,this.root); this._installFocusHandler(); };     View.prototype.openModal = function() { if (this.modal_elem) return; var lb = this.modal_elem = document.createElement("light-box"); if (View.lightbox_class) lb.classList.add(View.lightbox_class); else lb.setAttribute("style", "display:block;position:fixed;left:0;top:0;width:100vw;height:100vh;"+View.lightbox_style); document.body.appendChild(lb); this.open();  };  View.clearContent = function(element) { var event = new Event("remove"); var x = element.firstChild; while (x) { var y = x.nextSibling;  element.removeChild(x); x.dispatchEvent(event); x = y; }  };  View.prototype.clearContent = function() { View.clearContent(this.root); this.byName = {}; };    View.prototype.createView = function(name) { var elem = this.findElements(name); if (!elem) throw new Error("Cannot find item "+name);  if (elem.length != 1) throw new Error("The element must be unique "+name); var view = new View(elem[0]); return view; };    View.prototype.createCollection = function(selector, name) { var elems = this.findElements(selector); if (typeof selector == "string" && this.byName[selector]) name = selector;  var res = elems.reduce(function(sum, item){ var x = new GroupManager(item, name); this.groups.push(x); sum.push(x); return sum; },[]);  this.byName[name] = res; };    View.prototype.markClass = "mark";     View.prototype.findElements = function(selector) { if (typeof selector == "string") { if (selector) { var firstChar =selector.charAt(0); switch (firstChar) { case '.': case '[':  case '#': return Array.from(this.root.querySelectorAll(selector)); case '$': return Array.from(this.root.querySelectorAll(selector.substr(1))); default: return selector in this.byName?this.byName[selector]:[]; } } else { return [this.root]; } } else if (Array.isArray(selector)) { if (selector.length==1) { return this.findElements(selector[0]); } if (selector.length) { var gg = this.byName[selector.shift()]; if (gg) { var idx = selector.shift(); if (idx === null) { return gg.reduce(function(sum,item){ if (item.findElements) sum.push.apply(sum,item.findElements(selector)); return sum; },[]);  } else { var g = gg[idx]; if (g && g.findElements) { return g.findElements(selector); } } } }  } else if (typeof selector == "object" && selector instanceof Element) { return [selector]; }  return []; };     View.prototype.mark = function(selector) { var items = this.findElements(selector); var cnt = items.length; for (var i = 0; i < cnt; i++) { items[i].classList.add(this.markClass); this.marked.push(items[i]); }  };   View.prototype.forEachElement = function(selector, fn, a, b) { var items = this.findElements(selector); items.forEach(fn, a, b); };     View.prototype.unmark = function() { var cnt = this.marked.length; for (var i = 0; i < cnt; i++) { this.marked[i].classList.remove(this.markClass); } this.marked = []; };  View.prototype.anyMarked = function() { return this.marked.length > 0; };   View.prototype._installKbdHandler = function() { if (this.kbdHandler) return; this.kbdHandler = function(ev) { var x = ev.which || ev.keyCode; if (x == 13 && this.defaultAction && ev.target.tagName != "TEXTAREA" && ev.target.tagName != "BUTTON") { if (this.defaultAction(this)) { ev.preventDefault(); ev.stopPropagation(); } } else if (x == 27 && this.cancelAction) { if (this.cancelAction(this)) { ev.preventDefault(); ev.stopPropagation(); }  }  }.bind(this); this.root.addEventListener("keydown", this.kbdHandler); };    View.prototype.setDefaultAction = function(fn, el_name) { this.defaultAction = fn; this._installKbdHandler(); if (el_name) { var data = {}; data[el_name] = {"!click":fn}; this.setData(data) } };    View.prototype.setCancelAction = function(fn, el_name) { this.cancelAction = fn; this._installKbdHandler(); if (el_name) { var data = {}; data[el_name] = {"!click":fn}; this.setData(data) } };  function walkDOM(el, fn) { var c = el.firstChild; while (c) { fn(c); walkDOM(c,fn); c = c.nextSibling; } };    View.prototype._installFocusHandler = function(fn) { if (this.focus_top && this.focus_bottom) { if (this.focus_top.isConnected && this.focus_bottom.isConnected) this.focus_top.focus(); return; } var focusHandler = function(where, ev) { setTimeout(function() { where.focus(); },10);  };  var highestTabIndex=null; var lowestTabIndex=null; var firstElement=null; var lastElement = null; walkDOM(this.root,function(x){ if (typeof x.tabIndex == "number" && x.tabIndex != -1) { if (highestTabIndex===null) { highestTabIndex = lowestTabIndex = x.tabIndex; firstElement = x; } else { if (x.tabIndex >highestTabIndex) highestTabIndex = x.tabIndex; else if (x.tabIndex <lowestTabIndex) { lowestTabIndex= x.tabIndex; firstElement = x; } } if (x.tabIndex == highestTabIndex) lastElement = x; } });  if (firstElement && lastElement) { var le = document.createElement("focus-end"); le.setAttribute("tabindex",highestTabIndex); le.style.display="inline-block"; this.root.appendChild(le); le.addEventListener("focus", focusHandler.bind(this,firstElement));  var fe = document.createElement("focus-begin"); fe.setAttribute("tabindex",highestTabIndex); fe.style.display="inline-block"; this.root.insertBefore(fe,this.root.firstChild); fe.addEventListener("focus", focusHandler.bind(this,lastElement));  firstElement.focus(); }  this.focus_top = firstElement; this.focus_bottom = lastElement; };    View.prototype.setFirstTabElement = function(el) { this._installFocusHandler(); };  function GroupManager(template_el,name) { this.baseEl = template_el; this.parent = template_el.parentNode; this.anchor = document.createComment("><"); this.idmap={}; this.result = []; this.curOrder =[];  this.parent.insertBefore(this.anchor, this.baseEl); this.parent.removeChild(this.baseEl); this.name = name; template_el.dataset.group=true; template_el.removeAttribute("data-name"); template_el.removeAttribute("name");  };  GroupManager.prototype.isConnectedTo = function(elem) { return elem.contains(this.anchor); };  GroupManager.prototype.begin = function() { this.result = []; this.newOrder = [];  };   GroupManager.prototype.setValue = function(id, data) {  var x = this.idmap[id]; if (!x) { var newel = this.baseEl.cloneNode(true); var newview = new View(newel); x = this.idmap[id] = newview;  } else { this.lastElem = x.getRoot(); } this.newOrder.push(id); var t = data["@template"]; if (t) { x.loadTemplate(t); } var res = x.setData(data); if (res) this.result.push(res);  };  GroupManager.prototype.findElements = function(selector) { var item = selector.shift(); if (item === null) { var res = []; for (var x in this.idmap) { res.push.apply(res,this.idmap[x].findElements(selector)); } return res; } else {  return this.idmap[item]?this.idmap[item].findElements(selector):[]; } };  GroupManager.prototype.finish = function() { var newidmap = {};  this.newOrder.forEach(function(x){ if (this.idmap[x]) { newidmap[x] = this.idmap[x]; delete this.idmap[x]; } else { throw new Error("Duplicate row id: "+x);  }  },this); var oldp = 0; var oldlen = this.curOrder.length;  var newp = 0; var newlen = this.newOrder.length; var ep = this.anchor.nextSibling; var movedid = {}; while (oldp < oldlen) { var oldid = this.curOrder[oldp]; var newid = this.newOrder[newp]; if (oldid in this.idmap) { oldp++; ep = this.idmap[oldid].getRoot().nextSibling; } else if (oldid == newid) { oldp++; newp++; ep = newidmap[oldid].getRoot().nextSibling; } else if (!movedid[oldid]) { this.parent.insertBefore(newidmap[newid].getRoot(),ep); newp++; movedid[newid] = true; } else { oldp++; } } while (newp < newlen) {  var newid = this.newOrder[newp]; this.parent.insertBefore(newidmap[newid].getRoot(),ep); newp++;  } for (var x in this.idmap) { try { this.idmap[x].close(); } catch (e) {  } }  this.idmap = newidmap; this.curOrder = this.newOrder;  this.newOrder = []; return this.result;  };  GroupManager.prototype.readData = function() {  var out = [];  for (var x in this.idmap) { var d = this.idmap[x].readData(); d["@id"] = x; out.push(d);  } return out;  };    View.prototype.enableItem = function(name, enable) { var d = {}; d[name] = {"disabled":enable?null:""}; this.setData(d); };    View.prototype.showItem = function(name, showCmd) { var d = {}; if (typeof showCmd == "boolean") { this.showItem(name,showCmd?View.VISIBLE:View.HIDDEN); }else {  if (showCmd == View.VISIBLE) { d[name] = {".hidden":false,".style.visibility":""}; } else if (showCmd == View.TRANSPARENT) { d[name] = {".hidden":false,".style.visibility":"hidden"}; } else { d[name] = {".hidden":true}; } } this.setData(d); };    View.prototype.setItemEvent = function(name, event, fn) { var d = {}; var evdef = {}; evdef["!"+event] = fn; d[name] = evdef; this.setData(d);  };  View.prototype.setItemValue = function(name, value) { var d = {}; d[name] = {value:value}; this.setData(d); };  View.prototype.loadItemTemplate = function(name, template_name) { var v = View.createFromTemplate(template_name); this.setItemValue(name, v); return v; };  View.prototype.clearItem = function(name) { this.setItemValue(name, null); };    View.prototype.rebuildMap = function(rootel) { if (!rootel) rootel = this.root; this.byName = {};  this.groups = this.groups.filter(function(x) {return x.isConnectedTo(rootel);}); this.groups.forEach(function(x) {this.byName[x.name] = [x];},this);  function checkSubgroup(el) { while (el && el != rootel) { if (el.dataset.group) return true; el = el.parentElement; } return false; }  var elems = rootel.querySelectorAll("[data-name],[name]"); var cnt = elems.length; var i; for (i = 0; i < cnt; i++) { var pl = elems[i]; if (rootel.contains(pl) && !checkSubgroup(pl)) { var name = pl.name || pl.dataset.name || pl.getAttribute("name"); name.split(" ").forEach(function(vname) { if (vname) { if (vname && vname.endsWith("[]")) { vname = vname.substr(0,name.length-2); var gm = new GroupManager(pl, vname); this.groups.push(gm); if (!Array.isArray(this.byName[vname])) this.byName[vname] = []; this.byName[vname].push(gm); } else{ if (!Array.isArray(this.byName[vname])) this.byName[vname] = []; this.byName[vname].push(pl); } } },this);  } }  };    View.prototype.setData = function(data) { var me = this; var results = [];  function checkSpecialValue(val, elem) { if (val instanceof Element) { View.clearContent(elem); elem.appendChild(val); return true; } else if (val instanceof View) { View.clearContent(elem); elem.appendChild(val.getRoot()); return true; } else if (val instanceof Date && elem.type == "date") { elem.valueAsDate = val; return true; }  }  function isPromise(v) { return (typeof v == "object" && v instanceof Promise); }   function processItem(itm, elemArr, val) { var out = []; elemArr.forEach(function(elem) { var res ; if (elem) { var eltype = elem.tagName; if (elem.dataset && elem.dataset.type) eltype = elem.dataset.type;  var customEl = eltype && View.customElements[eltype.toUpperCase()];  if (typeof val == "object" && val !== null) { if (checkSpecialValue(val,elem)) { return  } else if (!Array.isArray(val)) {  if (!customEl || !customEl.setAttrs || !customEl.setAttrs(elem,val)) { updateElementAttributes(elem,val);  } if (!("value" in val)) { return; }else { val = val.value; if (typeof val == "object" && checkSpecialValue(val,elem)) return; } } } if (elem instanceof GroupManager) { var group = elem; group.begin(); if (Array.isArray(val) ) { var i = 0; var cnt = val.length; for (i = 0; i < cnt; i++) { var id = val[i]["@id"] || i; group.setValue(id, val[i]); } } res = group.finish(); out.push.apply(out,res); } else { function render_val(val) { if (customEl) { return customEl.setValue(elem,val); } else { return updateBasicElement(elem, val);  }  } if (val !== undefined) { if (isPromise(val)) res = val.then(render_val); else res = render_val(val); } if (res) out.push(res);; } } }); return out;  }  for (var itm in data) { var elemArr = this.findElements(itm); if (elemArr) { var val = data[itm]; if (isPromise(val)) { results.push(val.then(processItem.bind(this,itm,elemArr))); } else { var r = processItem(itm,elemArr,val); results.push.apply(results,r); } } } return Promise.all(results); };  var event_handlers = new WeakMap();  function updateElementAttributes (elem,val) { for (var itm in val) { if (itm == "value") continue; if (itm == "classList" && typeof val[itm] == "object") { for (var x in val[itm]) { if (val[itm][x]) { if (val[itm][x] === "restart") { elem.classList.remove(x); void elem.offsetWidth; } elem.classList.add(x);  } else elem.classList.remove(x); } } else if (itm.substr(0,1) == "!") { var name = itm.substr(1); var fn = val[itm]; var eh = event_handlers.get(elem); if (!eh) eh = {}; if (eh[name]) { var reg = eh[name]; elem.removeEventListener(name,reg);  } eh[name] = fn; elem.addEventListener(name, fn); event_handlers.set(elem,eh); } else if (itm.substr(0,1) == ".") {  var name = itm.substr(1); var obj = elem; var nextobj; var idx; var subkey; while ((idx = name.indexOf(".")) != -1) { subkey = name.substr(0,idx); nextobj = obj[subkey]; if (nextobj == undefined) { if (v !== undefined) nextobj = obj[subkey] = {}; else return; } name = name.substr(idx+1); obj = nextobj; } var v = val[itm]; if ( v === undefined) { delete obj[name]; } else { obj[name] = v; }  } else if (val[itm]===null) { elem.removeAttribute(itm); } else { elem.setAttribute(itm, val[itm].toString()) }  } };  function updateInputElement(elem, val) { var type = elem.getAttribute("type"); if (type == "checkbox" || type == "radio") { if (typeof (val) == "boolean") { elem.checked = !(!val); } else if (Array.isArray(val)) { elem.checked = val.indexOf(elem.value) != -1; } else if (typeof (val) == "string") { elem.checked = elem.value == val; }  } else if (type == "date" && typeof val == "object" && val instanceof Date) { elem.valueAsDate = val; } else { elem.value = val; } };   function updateSelectElement(elem, val) { if (typeof val == "object") { var curVal = elem.value; View.clearContent(elem); if (Array.isArray(val)) { var i = 0; var l = val.length; while (i < l) { var opt = document.createElement("option"); opt.appendChild(document.createTextNode(val[i].toString())); elem.appendChild(opt); i++; } } else { for (var itm in val) { var opt = document.createElement("option"); opt.appendChild(document.createTextNode(val[itm].toString())); opt.setAttribute("value",itm); elem.appendChild(opt);  } } elem.value = curVal; } else { elem.value = val; } };  function updateBasicElement (elem, val) { View.clearContent(elem); if (val !== null && val !== undefined) { elem.appendChild(document.createTextNode(val)); } };    View.prototype.readData = function(keys) { if (typeof keys == "undefined") { keys = Object.keys(this.byName); } var res = {}; var me = this; keys.forEach(function(itm) { var elemArr = me.findElements(itm); elemArr.forEach(function(elem){  if (elem) {  if (elem instanceof GroupManager) { var x = elem.readData(); if (res[itm] === undefined) res[itm] = x; else x.forEach(function(c){res[itm].push(c);}); } else if (!elem.dataset || !elem.dataset.readonly) { var val; var eltype = elem.tagName; if (elem.dataset.type) eltype = elem.dataset.type; var eltypeuper = eltype.toUpperCase(); if (View.customElements[eltypeuper]) { val = View.customElements[eltypeuper].getValue(elem, res[itm]); } else { val = readBasicElement(elem,res[itm]);  } if (typeof val != "undefined") { res[itm] = val; } } } }); }); return res; };  function readInputElement(elem, curVal) { var type = elem.getAttribute("type"); if (type == "checkbox") { if (!elem.hasAttribute("value")) { return elem.checked;  } else { if (!Array.isArray(curVal)) { curVal = []; } if (elem.checked) { curVal.push(elem.value); } return curVal; } } else if (type == "radio") { if (elem.checked) return elem.value; else return curVal; } else if (type == "number") { return elem.valueAsNumber;  } else if (type == "date") { return elem.valueAsDate; } else { return elem.value; } }; function readSelectElement(elem) { return elem.value;  };  function readBasicElement(elem) { var group = elem.template_js_group; if (group) { return group.readData();  } else { if (elem.contentEditable == "true" ) { if (elem.dataset.format == "html") return elem.innerHTML; else  return elem.innerText; } } };    View.regCustomElement = function(tagName, customElementObject) { var upper = tagName.toUpperCase(); View.customElements[upper] = customElementObject; };    View.createPageRoot = function(visibility ) { var elem = document.createElement(View.topLevelViewName); document.body.appendChild(elem); var view = new View(elem); view.setVisibility(visibility); return view; };  View.topLevelViewName = "div";    View.fromTemplate = function(id, def) { var t = loadTemplate(id);  if (t.nodeType == Node.DOCUMENT_FRAGMENT_NODE) { var x = t.firstElementChild; if (x != null && x.nextElementSibling == null) { t = x; } else { var el = createElement(def); el.appendChild(t); t = el; } } return new View(t); };  View.createFromTemplate = View.fromTemplate;  View.createEmpty = function(tagName, attrs) { if (tagName === undefined) tagName = "div"; var elem = document.createElement(tagName); if (attrs) { for (var v in attrs) { elem.setAttribute(v, attrs[v]); } } return new View(elem);  };  function CustomElementEvents(setval,getval,setattrs) { this.setValue = setval; this.getValue = getval; this.setAttrs = setattrs;  };  View.customElements = { "INPUT":{ "setValue":updateInputElement, "getValue":readInputElement, }, "TEXTAREA":{ "setValue":updateInputElement, "getValue":readInputElement, }, "SELECT":{ "setValue":updateSelectElement, "getValue":readSelectElement, }, "IMG":{ "setValue":function(elem,val) { elem.setAttribute("src",val); }, "getValue":function(elem) { elem.getAttribute("src"); } }, "IFRAME":{ "setValue":function(elem,val) { elem.setAttribute("src",val); }, "getValue":function(elem) { elem.getAttribute("src"); } } };   View.lightbox_style = "background-color:black;opacity:0.25";  View.lightbox_class = "";    return { "View":View, "loadTemplate":loadTemplate, "CustomElement":CustomElementEvents, "once":once, "delay":delay, "Animation":Animation, "removeElement":removeElement, "addElement":addElement, "waitForRender":waitForRender, "waitForRemove":waitForRemove, "waitForDOMUpdate":waitForDOMUpdate };  }();   
"use strict";  TemplateJS.View.regCustomElement("X-SLIDER", new TemplateJS.CustomElement( function(elem,val) { var range = elem.querySelector("input[type=range]"); var number = elem.querySelector("input[type=number]"); var mult = parseFloat(elem.dataset.mult); var fixed = parseInt(elem.dataset.fixed); var toFixed = function(v) { if (!isNaN(fixed)) return parseFloat(v).toFixed(fixed); else return v; }; if (!range) { range = document.createElement("input"); range.setAttribute("type","range"); number = document.createElement("input"); number.setAttribute("type","number"); number.setAttribute("step",mult); var env1 = document.createElement("div"); var env2 = document.createElement("div"); var min = parseFloat(elem.dataset.min); var max = parseFloat(elem.dataset.max); var rmin = Math.floor(min/mult); var rmax = Math.floor(max/mult); range.setAttribute("min",rmin); range.setAttribute("max",rmax); range.addEventListener("input",function() { var v = parseInt(this.value); var val = v * mult; number.value = toFixed(val); elem.dispatchEvent(new Event("change")); }); number.addEventListener("change", function() { var v = parseFloat(this.value); var val = v /mult; range.value = val; elem.dispatchEvent(new Event("change")); });  env1.appendChild(range); env2.appendChild(number); elem.appendChild(env1); elem.appendChild(env2); } range.value = val /mult; number.value = toFixed(val);   }, function(elem) { var number = elem.querySelector("input[type=number]"); if (number) return parseFloat(number.valueAsNumber); else return 0;  }, function(elem,attrs) {  } ));   TemplateJS.View.regCustomElement("X-CHECKBOX", new TemplateJS.CustomElement( function(elem,val) { var z = elem.querySelector("[data-name=inner"); if (z == null) { z = document.createElement("span"); z.setAttribute("data-name","inner");  elem.insertBefore(z, elem.firstChild); var w = document.createElement("span"); z.appendChild(w);  elem.addEventListener("click", function() { elem.classList.toggle("checked"); elem.dispatchEvent(new Event("change")); }); } elem.classList.toggle("checked", val); }, function(elem) { return elem.classList.contains("checked"); }  ));  TemplateJS.View.regCustomElement("X-SWITCH", new TemplateJS.CustomElement( function(elem, val) { if (elem.dataset.separator) { var arr = elem.dataset.value.split(elem.dataset.separator); elem.hidden = arr.indexOf(val) == -1; } else { elem.hidden = (elem.dataset.value!=val); } }, function(elem) { return undefined; } )); 
function beginOfDay(dt) { return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate()); } function invPrice(v, inv) { return inv?1/v:v; } function invSize(v, inv) { return (inv?-1:1)*v; }  function adjNum(n, decimals) { if (typeof n != "number") return n;  if (isNaN(n)) return "---"; if (!isFinite(n)) {  if (s < 0) return "-∞"; else return "∞"; } if (decimals !== undefined) return n.toFixed(decimals); var an = Math.abs(n); if (an >= 100000) return n.toFixed(0); else if (an >= 100) return n.toFixed(2); else if (an >= 1) return n.toFixed(4); else if (an > 0.0001) return n.toFixed(6); else { var s = (n*1000000).toFixed(3); if (s == "0.000") return s; return s+"µ"; } }  function adjNumN(n) { if (typeof n != "number") return n; var an = Math.abs(n); if (an >= 100000) return n.toFixed(0); else if (an >= 100) return n.toFixed(2); else if (an >= 1) return n.toFixed(4); else if (an > 0.0001) return n.toFixed(6); else { if (an === 0) return an; else { var s = n.toFixed(10);  while (s[s.length-1] == '0') { s = s.substr(0,s.length-1); } return s; } } }  function adjNumShort(n) { if (typeof n != "number") return n;  if (isNaN(n)) return "---"; if (!isFinite(n)) {  if (s < 0) return "-∞"; else return "∞"; } var an = Math.abs(n); if (an >= 10000000) return (n/1000000).toFixed(2).replace('.',"M"); else if (an >= 10000) return (n/1000).toFixed(2).replace('.',"k"); else if (an > 0.0001) { var s = n.toFixed(6); while (s[s.length-1] == '0') s = s.substr(0,s.length-1); if (s && s[s.length-1] == '.') s = s.substr(0,s.length-1); return s; } else { var s = (n*1000000).toFixed(3); if (s == "0.000") return s; return s+"µ"; } }  function pow2(x) { return x*x; }  function setElNumber(el, numb) { let pos = false; let neg = false; let zero = false; let na = false; if (!isNaN(numb)) { pos = numb > 0; neg = numb < 0; zero = numb == 0; } else { na = true; } el.classList.toggle("pos",pos); el.classList.toggle("neg",neg); el.classList.toggle("zero",zero); el.classList.toggle("na",na); el.classList.add("colornumber"); el.textContent = adjNum(numb); }  function binarySearch(array, predicate) { let l = 0; let h = array.length; while (l<h) { let m = Math.floor((l+h)/2); let dir = predicate(array[m]); if (dir > 0) { h = m; } else if (dir < 0) { l = m+1; } else { return array[m]; } } return l; } 
(function(){
  class SVG { constructor(root) { this._root = root; this._stack = []; };  new_element(name, attrs, childOf) { var elem = document.createElementNS("http://www.w3.org/2000/svg", name); if (attrs) { for (var i in attrs) { if (attrs[i] !== undefined) { elem.setAttributeNS(null,i, attrs[i]); } } } if (childOf) childOf.appendChild(elem); return elem;  };  create(width, height, xofs, yofs) { var x = xofs || 0; var y = yofs || 0; var vbx = x+" "+y+" "+width+" "+height; this._root = this.new_element("svg",{viewBox:vbx}); this._stack = []; };  clear() { while (this._root.firstChild) this._root.removeChild(this._root.firstChild);7 }  get() { return this._root; };  pop() { let t = this._stack.pop(); if (t) this._root = t;  };  line(x1, y1, x2, y2) { this.new_element("line",{x1:x1,y1:y1,x2:x2,y2:y2},this._root); }; circle(x, y,r) { this.new_element("circle",{cx:x,cy:y,r:r},this._root); }; ellipse(x, y,rx,ry) { this.new_element("ellipse",{cx:x,cy:y,rx:rx,ry:ry},this._root); }; rect(x, y,w,h,rx,ry) { this.new_element("rect",{x:x,y:y,width:w,height:h,rx:rx,ry:ry},this._root); }; gradrect(x, y,w,h,vert) { let id = "svg"+(Math.random() + 1).toString(36).substring(7); let d = this.new_element("defs",{},this._root); let g = this.new_element("linearGradient",{id:id,x1:0,y1:0,x2:vert?"100%":0,y2:vert?0:"100%"},d); this.new_element("stop",{offset:"0%"},g); this.new_element("stop",{offset:"100%"},g); this.new_element("rect",{x:x,y:y,width:w,height:h,fill:"url(#"+id+")"},this._root); }; polyline(points, className) { this.new_element("polyline",{points:points.map(function(x){ return x.join(' ') }).join(','),class:className},this._root); }; polygon(points, className) { this.new_element("polygon",{points:points.map(function(x){ return x.join(' ') }).join(','),class:className},this._root); }; push_group(className) { let e = this.new_element("g",{class:className},this._root); this._stack.push(this._root); this._root = e; return e; };  text(x,y,text,className) { let e = this.new_element("text",{x:x,y:y,class:className},this._root); this.set_text(e,text); return e; }; text_space(x,y,text,len) { let r = (Math.random() + 1).toString(36).substring(7); this.new_element("path",{id:"path_"+r,d:"M"+x+","+y+" h"+len,stroke:"none",fill:"none"},this._root); let t = this.new_element("text",{},this._root); let e = this.new_element("textPath",{href:"#path_"+r},t); this.set_text(e,text); return e; };  image(x,y,width,height,href,aspect) { return this.new_element("image",{x:x,y:y,width:width,height:height,href:href,preserveAspectRatio:aspect},this._root);ss  } push_viewport(x,y,width,height,vbx_x, vbx_y,vbx_width,vbx_height) { if (vbx_x === undefined) vbx_x = 0; if (vbx_y === undefined) vbx_y = 0; if (vbx_width === undefined) vbx_width = width; if (vbx_height === undefined) vbx_height = height; var vbx = vbx_x+" "+vbx_y+" "+vbx_width+" "+vbx_height; let e = this.new_element("svg", { x:x,y:y,width:width,height:height,viewBox:vbx },this._root); this._stack.push(this._root); this._root = e; return e; }  set_text(e, text) { while (e.firstChild) e.removeChild(e.firstChild); if (Array.isArray(text)) { text.forEach(function(z){ let n = this.new_element("tspan",{},e);  n.appendChild(document.createTextNode(z));  },this); } else { e.appendChild(document.createTextNode(text)); }  }  };   mmbot.SVG = SVG; 
})();(function(){
  class Source { constructor() { this.waitPromise = null; this._waitFn = function() { }; this.broadcast({}); } listen() { return this.waitPromise; } broadcast(obj) { var ntf = this._waitFn; this.waitPromise = new Promise(function(ok) { this._waitFn = ok; }.bind(this)); obj.next = this.waitPromise; ntf(obj); } };    mmbot.Source = Source; 
})();(function(){
   class DataStream extends mmbot.Source { constructor() { super();  var src = new EventSource("./data", { withCredentials: true }); src.onmessage = function(msg) { var jmsg = JSON.parse(msg.data); if (typeof jmsg == "string") { switch (jmsg) { case "refresh": this.broadcast({ type: "refresh", state: true }); break; case "end_refresh": this.broadcast({ type: "refresh", state: false }); break; case "ping": this.broadcast({ type: "ping" }); break; }; } else if (jmsg.type) { var fn = this["update_" + jmsg.type]; if (fn) fn.call(this, jmsg); delete jmsg.data; this.broadcast(jmsg); } }.bind(this); this.traders = {}; this.log = []; } getTrader(symbol) { var x = this.traders[symbol]; if (!x) x = this.traders[symbol] = {}; return x; } update_order(msg) { var t = this.getTrader(msg.symbol); if (!t.orders) t.orders = {}; t.orders[msg.dir < 0 ? "sell" : "buy"] = msg.data; } update_misc(msg) { var t = this.getTrader(msg.symbol); t.prev_misc = t.misc || msg.data; t.misc = msg.data; } update_info(msg) { var t = this.getTrader(msg.symbol); t.info = msg.data; } update_trade(msg) { var t = this.getTrader(msg.symbol); if (!t.trades) t.trades = {}; t.trades[msg.id] = msg.data; } update_price(msg) { var t = this.getTrader(msg.symbol); t.price = msg.data; } update_error(msg) { var t = this.getTrader(msg.symbol); t.error = msg.data; } update_config(msg) { this.config = msg.data; } update_performance(msg) { this.performance = msg.data; } update_version(msg) { this.version = msg.data; } update_log(msg) { this.log.push(msg.data); } };   mmbot.DataStream = DataStream;  
})();(function(){
  class MKO { constructor(fn, tm) { this.fn = fn; this.tm = tm; this.tid = null; this.promise = Promise.resolve(); }  event(x) { if (this.tid) { clearTimeout(this.tid); } else { this.promise = new Promise(ok=>{this.ok = ok}) ; }  this.tid = setTimeout(()=>{ this.tid = null; this.fn(x);  this.ok(); },this.tm); }  wait() { return this.promise; } };  mmbot.MKO = MKO;
})();(function(){
    class Sumprofit extends mmbot.Source {  constructor() { super();  };  clear() { this.symbol_map = new Map; this.wallet_map = new Map;  };  set_source(src) { if (this.src) this.src.broadcast({type:"stop",obj:this}); this.src = src; this.src.listen().then(this.run_cycle.bind(this)); this.clear(); for (const c in src.traders) {  this.recalc(this.register_wid(c)); }  };  register_wid(s) { this.symbol_map.delete(s); const nfo = this.src.traders[s].info; const wid = nfo.brokerName+"/"+nfo.walletId+"/"+nfo.currency; this.symbol_map.set(s, wid); return wid;  };  run_cycle(event) { if (event.type != "stop" || event.obj == this) {  if (event.type == "info") { const wid = this.register_wid(event.symbol); this.recalc(wid);  } if (event.type == "trade") { const wid = this.register_wid(event.symbol); this.recalc(wid); } if (event.type == "price") { const wid = this.register_wid(event.symbol); this.recalc_price(wid, event.symbol, this.src.traders[event.symbol].price);  }  event.next.then(this.run_cycle.bind(this)); } };  getwdef(wid) { let wdef = this.wallet_map.get(wid); if (!wdef) { wdef = {}; wdef.mko = new mmbot.MKO(()=>{ this.recalc_delayed(wid); },500); this.wallet_map.set(wid,wdef); } return wdef;  };   recalc(wid) { let wdef = this.getwdef(wid); wdef.mko.event(); }; recalc_delayed(wid) { let wdef = this.getwdef(wid); var trades = []; var last_symbol;  for (const item of this.symbol_map) { if (item[1] == wid) { var s = item[0]; const ltrades = this.src.traders[s].trades; if (ltrades) { last_symbol = s; for (const tr of Object.values(ltrades)) { trades.push(Object.assign({trader:s},tr)); } } } } if (last_symbol) { const nfo = this.src.traders[last_symbol].info;  const misc = this.src.traders[last_symbol].misc;  wdef.info = {symbol:nfo.currency, wallet: nfo.walletId, broker: nfo.brokerName, icon: nfo.brokerIcon, be: misc.be}; } trades.sort(function(a,b){return a.time - b.time;}); wdef.last={}; let recent_symbols={}; let sums = trades.reduce(function(acc, item){ let len = acc.length; var last = len == 0?{pnl:0,norm:0}:acc[len-1]; acc.push({ time: item.time, pnl: last.pnl+item.gain, norm: last.norm+item.normch, _d_pnl: item.gain, _d_norm: item.normch, }); wdef.last[item.trader]=Object.assign({},item); recent_symbols[item.trader] = item.time;  return acc; },[]); wdef.serie = sums; wdef.slen = sums.length; recent_symbols = Object.keys(recent_symbols).map(n=>[recent_symbols[n],n]); recent_symbols.sort((a,b)=>b[0]-a[0]); wdef.recent_symbols = recent_symbols;  this.broadcast({wid:wid}); };  async recalc_price(wid, symbol, price) { let wdef = this.getwdef(wid); if (wdef.slen == 0) return; await wdef.mko.wait(); let last = wdef.last[symbol]; if (!last) return; last.new_price = price; let sum = Object.values(wdef.last).reduce((a,x)=>{ let last_price = x.price; let recent_price = x.new_price || x.price; let inv = this.src.traders[x.trader].info.inverted; let pnl = inv?(x.pos*(1.0/last_price-1.0/recent_price)):(x.pos*(recent_price-last_price)); return a+pnl;  },0); let lastItem = wdef.serie[wdef.slen-1]; let newItem = { time:Date.now(), pnl:lastItem.pnl+sum, norm: lastItem.norm, _d_pnl: sum, _d_norm: 0 }; if (wdef.serie.length>wdef.slen) wdef.serie[wdef.slen] = newItem; else wdef.serie.push(newItem);  this.broadcast({wid:wid});  };  get_total(wid) { let wdef = this.getwdef(wid); let last = wdef.last; if (!last) return 0; let sum = Object.values(wdef.last).reduce((a,x)=>{ return {pnl: a.pnl+x.pl,norm: a.norm+x.norm} },{pnl:0,norm:0}); return sum; }; get_recent(wid, interval, rel_to_now) { const wdef = this.getwdef(wid); const serie = wdef.serie; let res = {pnl:0, norm:0}; if (!wdef.slen) return res; const start = (rel_to_now?Date.now():serie[wdef.slen-1].time)-interval; const start_pos = binarySearch(serie, x=>x.time-start); const b = start_pos?serie[start_pos-1]:res; const e = serie[wdef.slen-1]; res.pnl = e.pnl - b.pnl; res.norm = e.norm - b.norm; return res; }; get_recent_symbols(wid) { const wdef = this.getwdef(wid); return wdef.recent_symbols; }; get_source() { return this.src }; get_range(wid) { const wdef = this.getwdef(wid); let res = {pnl:0, norm:0}; if (wdef.serie.length == 0) return res; const l = wdef.serie[wdef.serie.length-1]; res.norm = l.norm; res.pnl = l.pnl; return res; } };  mmbot.Sumprofit = Sumprofit;  
})();(function(){
   class ProfitPanel {  constructor(src, walletId) { this._src = src; this._walletId = walletId; const pnl_line=120; const norm_line=150; const asset_line1=185; const asset_line2=210; const col1=150; const col2=290; const col3=445; const col4=600; const colm=5; const acol1l=110; const acol1a=115; const acol1p=320; const acol2l=390; const acol2a=395; const acol2p=600;  let svg = new mmbot.SVG(); svg.create(600,215); svg.push_group("brokerimg"); this.brokerImg = svg.image(0,10,64,64,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAQAAAD9CzEMAAADO0lEQVRYw9WXTUhUURTHz6OJ3EiNMJCRxGyGcuFiQBcuWgzhooWLFgVGLlzMwkXhwkXQwkXgQmghSBupheBqQBKEIGgREkhhkkwmkRaTzVSohGn51a/FPN+c++a9efPVwru679xzz7nn63/OEznuy/Im0yk35ZR8lCfWuzprpJkM5pqup/hJW+g8t0kywqr9fa0+4p8D0OuipgAYroeCZfYIedDbAOisTXjE/XIz6AC1KdjVAoAsPwzKODBRi4L7R9dpYM7JoIhzHqrJBhpodPa9RpI6MWEBaKtWwYbhji0gSowZoMeh9uRziTgJEiSIVaLAMJ91YJoZ9oHLBleaFsO+iTKhAkQsq6BAmhyO11Z7QYG8ty4xLhdEROSinBcRkZPWQTUWJOiiS9MJA7Oue6+AkuKPQvhTThNyXtIkIjfkhIv3log8dTmgnRWJ0mc9CrLgMZC09/2Gl0cdnhwQDrLeT4GR5SpRYyqRPQQREmEnT/cCGc26pjGTDFPMsKrO0wUbHdoAkGQe3Ejg3QcAWn1Ohzzfn0/ZfWAdSAe5Kemngrvg4/+Y48y1csptGICXNChaK7/BLDjjTgcAv8qt6G7nRYvMk7X3ezSXuJNguVJc1WuLq/9l3CBGawGsfdJiWj1kkZbKFIwVANynvR6tv85uo/QdfX0JQAfbOI3aAgcUrcemxcsRP1vcbtxVT8qvWogGiU8pz3ogJXvApM/dwTKQKV9uQIo5oM912g8GhDSS0eEl5a++kNeNRIAlEbo91YddlfNAuxL4UHETVdMTZNT3ouPMVKV1MAPc80hejbnXAciSJafnPlZ0fpXsEEVz6hKoAWe0mMO2/jDg/yAPc5IWkT/yUBZEROST9YJNOaOGg2b5am+/WDrQxghRyoooWxqWRNg0I0MnObbd07eOX6AeInLHHlPeWiM8kytyzsoW8XyXN1ZcWfDNOlsdBCaBMc8hM2GEfqp6lNXDQdwBun7FkYNS/SNIwWf9WvvPYdDVpw9r6xPoVBWho6jSa2tRjPrhrAjbwHzt3S5jhtUZDwAOAgawMlXkIf2QEaKEiDDEDpQxG1WgIs4u7lXv8YAww6TJscJYYB87tusf8bF7YIB0L5gAAAAASUVORK5CYII="); svg.pop(); svg.push_group("symbolname"); this.symbolName = svg.text_space(64,46,"SYMBOL",136); svg.pop(); svg.push_group("walletname"); this.walletInfo = svg.text_space(64,70,"brokerId walletId",136); svg.pop(); svg.push_viewport(200,0,145,84); svg.push_group("frame");svg.gradrect(0,0,"100%","100%");svg.gradrect(0,0,"100%","100%",true);svg.pop(); this.pnlchart = svg.push_group("chart");svg.pop(); svg.push_group("chartlabels"); svg.text(2,"99.5%","PnL"); svg.pop(); svg.pop(); svg.push_viewport(350,0,145,84); svg.push_group("frame");svg.gradrect(0,0,"100%","100%");svg.gradrect(0,0,"100%","100%",true);svg.pop(); this.normchart = svg.push_group("chart");svg.pop(); svg.push_group("chartlabels"); svg.text(2,"99.5%","Norm.profit"); svg.pop(); svg.pop(); svg.push_group("budgetextra"); svg.text(550,25,"Budget"); svg.text(550,42,"extra");  this.budgetExtra = svg.text(550,70,"+9999999"); svg.pop(); svg.push_group("statslabelsbg"); const height = 10; [[0,col1],[col1+colm-2,col2],[col2+colm-2,col3],[col3+colm-2,col4]].forEach(x=>{ svg.gradrect(x[0],pnl_line-height, x[1]-x[0],height+3); svg.gradrect(x[0],norm_line-height, x[1]-x[0],height+3); }); svg.pop(); svg.push_group("statslabelsbig"); svg.text(2,pnl_line,"PnL:"); svg.text(2,norm_line,"Norm:"); svg.text(2,asset_line1,"Posit:"); svg.pop(); svg.push_group("statslabels"); svg.text(col1+colm,pnl_line,"last:"); svg.text(col1+colm,norm_line,"last:"); svg.text(col2+colm,pnl_line,"24h:"); svg.text(col2+colm,norm_line,"24h:"); svg.text(col3+colm,pnl_line,"range:"); svg.text(col3+colm,norm_line,"range:"); svg.pop(); svg.push_group("stats"); this.pnl_total=svg.text(col1,pnl_line,"+9999999"); this.norm_total=svg.text(col1,norm_line,"+9999999"); this.pnl_last=svg.text(col2,pnl_line,"+9999999"); this.norm_last=svg.text(col2,norm_line,"+9999999"); this.pnl_24h=svg.text(col3,pnl_line,"+9999999"); this.norm_24h=svg.text(col3,norm_line,"+9999999"); this.pnl_range=svg.text(col4,pnl_line,"+9999999"); this.norm_range=svg.text(col4,norm_line,"+9999999"); svg.pop(); svg.push_group("assetslabels"); this.assets=[{},{},{},{}]; this.assets[0].name=svg.text(acol1l,asset_line1,"ASSET1"); this.assets[1].name=svg.text(acol2l,asset_line1,"ASSET2"); this.assets[2].name=svg.text(acol1l,asset_line2,"ASSET3"); this.assets[3].name=svg.text(acol2l,asset_line2,"ASSET4"); svg.pop(); svg.push_group("assets"); this.assets[0].pos=svg.text(acol1a,asset_line1,"+9999POS"); this.assets[1].pos=svg.text(acol2a,asset_line1,"+9999POS"); this.assets[2].pos=svg.text(acol1a,asset_line2,"+9999POS"); this.assets[3].pos=svg.text(acol2a,asset_line2,"+9999POS"); svg.pop(); svg.push_group("prices"); this.assets[0].price=svg.text(acol1p,asset_line1,"+99PRICE"); this.assets[1].price=svg.text(acol2p,asset_line1,"+99PRICE"); this.assets[2].price=svg.text(acol1p,asset_line2,"+99PRICE"); this.assets[3].price=svg.text(acol2p,asset_line2,"+99PRICE"); svg.pop(); this._root = svg.get(); this.positions=[]; for (let i = 0; i<4; i++) this.positions.push({ id:"", name:"", price:"", pos:"", prev_pos:"", time:0 }); this.posmap={}; }  appendTo(element) { element.appendChild(this._root); }  getWalletID() { return this._walletId; }  update() { const wid = this._src.getwdef(this._walletId); if (!wid.info) return; this.symbolName.textContent = wid.info.symbol; this.brokerImg.setAttribute("href",wid.info.icon); this.walletInfo.textContent = wid.info.broker+" "+wid.info.wallet; let recent24 = this._src.get_recent(this._walletId,24*60*60*1000,true); setElNumber(this.norm_24h,recent24.norm); setElNumber(this.pnl_24h,recent24.pnl); let last = this._src.get_recent(this._walletId,60*1000,false); setElNumber(this.norm_last,last.norm); setElNumber(this.pnl_last,last.pnl); let total = this._src.get_total(this._walletId); setElNumber(this.norm_total,total.norm); setElNumber(this.pnl_total,total.pnl); let range = this._src.get_range(this._walletId); setElNumber(this.norm_range,range.norm); setElNumber(this.pnl_range,range.pnl); setElNumber(this.budgetExtra,wid.info.be); const s = wid.serie.slice(-50); this.drawChart(this.pnlchart, s.map(x=>x.pnl)); this.drawChart(this.normchart, s.map(x=>x.norm));  let recsymb = this._src.get_recent_symbols(this._walletId); const dsrc = this._src.get_source(); recsymb.forEach(x=>{ let itm = this.positions.find(z=>z.id == x[1]); if (!itm) { itm = this.positions.reduce((a,x)=>{ return a.time<=x.time?a:x; },{time:x[0]}); itm.id = x[1]; } if (itm) { const trd = dsrc.traders[x[1]]; if (trd) { itm.name = trd.info.asset; itm.pos = trd.misc.pos; itm.prev_pos = trd.prev_misc.pos; itm.price = trd.price; itm.time = x[0];  } } });   this.positions.forEach((x,idx)=>{ let cntr = this.assets[idx];  let recent = (Date.now() - x.time)<60000;  cntr.name.textContent = x.name; cntr.pos.textContent = adjNum(x.pos); cntr.price.textContent = adjNum(x.price); cntr.pos.classList.toggle("flashing",x.pos != x.prev_pos && recent); cntr.pos.classList.toggle("sell",x.pos < x.prev_pos && recent); cntr.pos.classList.toggle("buy",x.pos > x.prev_pos && recent);  }); }   drawChart(chart, series) { let svg = new mmbot.SVG(chart); svg.clear(); if (series.length) { let minmax = series.reduce((a,x)=>{return { min:a.min<x?a.min:x, max:a.max>x?a.max:x  }},{min:series[0],max:series[0]}); let mx = 130/(series.length-1); let my = 70/(minmax.max-minmax.min); let points = series.map((v,idx)=>{ return [(idx * mx+6), (75-(v - minmax.min)*my)]; }); svg.polyline(points); } }   };  class ProfitPanelControl { constructor(source) { this._src = source; let panels = this._panels = new Map;  function ondata(x) { let p = panels.get(x.wid); if (!p) { p = new ProfitPanel(source, x.wid); panels.set(x.wid, p); if (this._appendToElem) p.appendTo(this._appendToElem); } p.update();  x.next.then(ondata.bind(this)); }  this._src.listen().then(ondata.bind(this)); };  appendTo(elem) { for(let c in this._panels) { c.appendTo(elem); } this._appendToElem = elem;  } };  mmbot.ProfitPanel = ProfitPanel; mmbot.ProfitPanelControl = ProfitPanelControl; 
})();(function(){
               document.body.onload=function() { let app = mmbot.app = new App(); app.uitest(); window.thisApp = app; app.waitForInit().then(()=>{ app._profitpanels.appendTo(document.getElementById("main_panel")); }); };   class App { constructor() {  this._source = new mmbot.DataStream();   }  async waitForInit() { let ev = await this._source.listen(); while (ev.type != "refresh" || ev.state) { ev = await ev.next; } console.log("Init!"); this._sumprofit = new mmbot.Sumprofit(); this._sumprofit.set_source(this._source); this._profitpanels = new mmbot.ProfitPanelControl(this._sumprofit); }   uitest() {    }  };
})();</script></BODY></HTML>